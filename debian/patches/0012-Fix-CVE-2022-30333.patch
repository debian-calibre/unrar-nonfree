From: YOKOTA Hiroshi <yokota.hgml@gmail.com>
Date: Tue, 10 May 2022 20:25:13 +0900
Subject: Fix CVE-2022-30333

Forwarded: not-needed
---
 ulinks.cpp | 36 +++++++++++++++++++++++++++++++-----
 1 file changed, 31 insertions(+), 5 deletions(-)

diff --git a/ulinks.cpp b/ulinks.cpp
index 1656824..2555ac4 100644
--- a/ulinks.cpp
+++ b/ulinks.cpp
@@ -45,6 +45,26 @@ static bool IsFullPath(const char *PathA) // Unix ASCII version.
 }
 
 
+// For security purpose we prefer to be sure that CharToWide completed
+// successfully and even if it truncated a string for some reason,
+// it didn't affect the number of path related characters we analyze
+// in IsRelativeSymlinkSafe later.
+// This check is likely to be excessive, but let's keep it anyway.
+static bool SafeCharToWide(const char *Src,wchar *Dest,size_t DestSize)
+{
+  if (!CharToWide(Src,Dest,DestSize) || *Dest==0)
+    return false;
+  uint SrcChars=0,DestChars=0;
+  for (uint I=0;Src[I]!=0;I++)
+    if (Src[I]=='/' || Src[I]=='.')
+      SrcChars++;
+  for (uint I=0;Dest[I]!=0;I++)
+    if (Dest[I]=='/' || Dest[I]=='.')
+      DestChars++;
+  return SrcChars==DestChars;
+}
+
+
 bool ExtractUnixLink30(CommandData *Cmd,ComprDataIO &DataIO,Archive &Arc,const wchar *LinkName)
 {
   char Target[NM];
@@ -67,12 +87,12 @@ bool ExtractUnixLink30(CommandData *Cmd,ComprDataIO &DataIO,Archive &Arc,const w
       return true;
 
     wchar TargetW[NM];
-    CharToWide(Target,TargetW,ASIZE(TargetW));
-    // Check for *TargetW==0 to catch CharToWide failure.
+    if (!SafeCharToWide(Target,TargetW,ASIZE(TargetW)))
+      return false;
     // Use Arc.FileHead.FileName instead of LinkName, since LinkName
     // can include the destination path as a prefix, which can
     // confuse IsRelativeSymlinkSafe algorithm.
-    if (!Cmd->AbsoluteLinks && (*TargetW==0 || IsFullPath(TargetW) ||
+    if (!Cmd->AbsoluteLinks && (IsFullPath(TargetW) ||
         !IsRelativeSymlinkSafe(Cmd,Arc.FileHead.FileName,LinkName,TargetW)))
       return false;
     return UnixSymlink(Target,LinkName,&Arc.FileHead.mtime,&Arc.FileHead.atime);
@@ -95,11 +115,17 @@ bool ExtractUnixLink50(CommandData *Cmd,const wchar *Name,FileHeader *hd)
       return false;
     DosSlashToUnix(Target,Target,ASIZE(Target));
   }
+
+  wchar TargetW[NM];
+  if (!SafeCharToWide(Target,TargetW,ASIZE(TargetW)))
+    return false;
   // Use hd->FileName instead of LinkName, since LinkName can include
   // the destination path as a prefix, which can confuse
   // IsRelativeSymlinkSafe algorithm.
-  if (!Cmd->AbsoluteLinks && (IsFullPath(Target) ||
-      !IsRelativeSymlinkSafe(Cmd,hd->FileName,Name,hd->RedirName)))
+  // 2022.05.04: Use TargetW instead of previously used hd->RedirName
+  // for security reason.
+  if (!Cmd->AbsoluteLinks && (IsFullPath(TargetW) ||
+      !IsRelativeSymlinkSafe(Cmd,hd->FileName,Name,TargetW)))
     return false;
   return UnixSymlink(Target,Name,&hd->mtime,&hd->atime);
 }
